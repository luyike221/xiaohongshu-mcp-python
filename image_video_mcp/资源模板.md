# Resource Template 教学指南

## 📚 核心概念

### 什么是 Resource Template？

Resource Template（资源模板）是 FastMCP 中一种**动态资源**机制，它允许你根据 URI 中传递的参数，动态生成和返回不同的资源内容。

**简单理解**：
- **静态 Resource**：固定内容，URI 固定，返回固定数据
- **Resource Template**：动态内容，URI 包含参数，根据参数返回不同数据

### 类比理解

想象一下：

- **静态 Resource** = 图书馆的固定书架
  - 每个书架位置固定（URI 固定）
  - 书架上的书不会变（内容固定）
  - 例如：`resource://books` 总是返回所有书籍列表

- **Resource Template** = 图书馆的查询系统
  - 你可以输入书名、作者等参数（URI 包含参数）
  - 系统根据参数返回不同的结果（动态内容）
  - 例如：`resource://book/{book_id}` 根据 book_id 返回不同的书籍

## 🎯 使用场景

### 什么时候使用 Resource Template？

1. **需要根据参数返回不同数据**
   - 根据用户ID获取用户信息
   - 根据产品ID获取产品详情
   - 根据风格名称获取风格配置

2. **数据量大，需要按需获取**
   - 不是一次性返回所有数据
   - 只返回用户请求的特定部分

3. **需要组合多个数据源**
   - 根据多个参数组合生成配置
   - 例如：风格 + 尺寸 = 完整配置

### 什么时候使用静态 Resource？

1. **数据量小，可以一次性返回**
   - 配置列表
   - 预设数据
   - 模板库

2. **内容相对固定**
   - 不经常变化的数据
   - 参考数据

## 🏗️ 设计思路

### 思路 1：数据与接口分离

**核心思想**：将数据定义和接口暴露分开

```
数据层（模块级别）
  ├─ 数据字典/数据库
  └─ 辅助函数（访问数据）

接口层（Resource/Resource Template）
  ├─ 静态 Resource（暴露完整数据）
  └─ Resource Template（根据参数返回部分数据）
```

**为什么这样做？**
- Resource Template 需要访问底层数据
- 如果通过 `mcp.get_resource()` 调用其他 Resource，会得到 `FunctionResource` 对象
- 直接访问数据更简单、更高效

### 思路 2：URI 设计原则

**URI 应该清晰表达资源层次和参数**

```
好的 URI 设计：
resource://users/{user_id}/profile          # 用户资料
resource://products/{product_id}/reviews   # 产品评论
resource://styles/{style_name}             # 风格配置

不好的 URI 设计：
resource://data/{id}                        # 太泛化，不知道是什么数据
resource://get/{param}                      # 动词不应该在 URI 中
```

**URI 参数规则**：
- 参数名必须与函数参数名完全匹配
- 所有路径参数都是必需的（不能有默认值）
- 使用有意义的参数名

### 思路 3：错误处理策略

**两种方式**：

1. **返回错误字典**（更友好）
   ```伪代码
   如果 数据不存在:
       返回 {
           "error": "错误信息",
           "available_options": ["选项1", "选项2"]
       }
   ```

2. **抛出异常**（更标准）
   ```伪代码
   如果 数据不存在:
       抛出 ResourceError("错误信息")
   ```

**建议**：对于参数错误（如无效的风格名称），返回错误字典更友好；对于系统错误（如数据库连接失败），抛出异常更合适。

## 🔄 工作流程

### 完整流程

```
1. 客户端请求
   └─ URI: resource://styles/anime
      └─ 参数: style_name = "anime"

2. FastMCP 路由
   └─ 匹配到 Resource Template: resource://styles/{style_name}
      └─ 提取参数: style_name = "anime"

3. 执行函数
   └─ 调用 get_image_style(style_name="anime")
      └─ 访问数据: IMAGE_STYLES["anime"]
         └─ 返回结果

4. 返回响应
   └─ 客户端收到风格配置数据
```

### 数据流向

```
模块级别数据
  └─ IMAGE_STYLES = {...}
     └─ Resource Template 函数
        └─ 根据参数访问数据
           └─ 返回结果给客户端
```

## 💡 设计模式

### 模式 1：简单查询

**场景**：根据单个参数返回单个数据项

```伪代码
@resource("resource://items/{item_id}")
函数 get_item(item_id):
    数据 = 数据字典[item_id]
    如果 数据存在:
        返回 数据
    否则:
        返回 错误信息
```

### 模式 2：组合查询

**场景**：根据多个参数组合生成结果

```伪代码
@resource("resource://config/{style}/{size}")
函数 get_config(style, size):
    风格数据 = 风格字典[style]
    尺寸数据 = 尺寸字典[size]
    
    如果 风格数据 和 尺寸数据 都存在:
        返回 {
            "style": 风格数据,
            "size": 尺寸数据,
            "combined": 组合后的配置
        }
    否则:
        返回 错误信息
```

### 模式 3：嵌套查询

**场景**：Resource Template 内部调用其他 Resource Template

```伪代码
@resource("resource://plan/{theme}/{style}/{size}")
函数 get_plan(theme, style, size):
    # 注意：不能通过 mcp.get_resource() 调用其他 Resource Template
    # 应该直接访问底层数据
    
    风格 = 风格字典[style]
    尺寸 = 尺寸字典[size]
    负面提示词 = 负面提示词字典["general"]
    
    返回 {
        "theme": theme,
        "style": 风格,
        "size": 尺寸,
        "negative_prompt": 负面提示词,
        "steps": 生成步骤列表
    }
```

## 🎨 最佳实践

### 1. 数据组织

**推荐**：将数据定义在模块级别

```伪代码
# 模块级别（全局可访问）
数据字典 = {
    "key1": {...},
    "key2": {...}
}

函数 register_resources(mcp):
    @resource("resource://data")
    函数 get_data():
        返回 数据字典
```

**不推荐**：数据定义在函数内部

```伪代码
函数 register_resources(mcp):
    数据字典 = {...}  # 局部变量，其他模块无法访问
    
    @resource("resource://data")
    函数 get_data():
        返回 数据字典
```

### 2. 函数设计

**推荐**：简单、专注的函数

```伪代码
@resource("resource://styles/{style_name}")
函数 get_style(style_name):
    # 只做一件事：根据名称获取风格
    风格 = 风格字典[style_name]
    返回 风格
```

**不推荐**：功能复杂的函数

```伪代码
@resource("resource://styles/{style_name}")
函数 get_style(style_name):
    # 做了太多事情：验证、转换、组合、计算...
    如果 验证失败:
        返回 错误
    风格 = 获取风格(style_name)
    转换后的风格 = 转换格式(风格)
    组合数据 = 组合其他数据(转换后的风格)
    计算结果 = 执行复杂计算(组合数据)
    返回 计算结果
```

### 3. 错误处理

**推荐**：提供有用的错误信息

```伪代码
如果 数据不存在:
    返回 {
        "error": "风格 'xxx' 不存在",
        "available_styles": ["realistic", "anime", ...]
    }
```

**不推荐**：模糊的错误信息

```伪代码
如果 数据不存在:
    返回 {"error": "错误"}
```

### 4. URI 命名

**推荐**：清晰、有意义的命名

```伪代码
resource://users/{user_id}/profile
resource://products/{product_id}/reviews
resource://styles/{style_name}
```

**不推荐**：模糊、无意义的命名

```伪代码
resource://data/{id}
resource://get/{param}
resource://item/{x}
```

## 🔍 常见问题

### Q1: 为什么不能在 Resource Template 中调用其他 Resource？

**A**: 因为 `mcp.get_resource()` 返回的是 `FunctionResource` 对象（被装饰器包装的函数），而不是实际的字典数据。

**解决方案**：直接访问模块级别的数据字典。

### Q2: Resource Template 函数必须是异步的吗？

**A**: 不一定。如果只是访问内存中的数据字典，使用同步函数即可。只有在需要异步操作（如数据库查询、API 调用）时才使用异步函数。

### Q3: 如何设计多参数的 Resource Template？

**A**: 在 URI 中使用多个路径参数，函数参数名必须与 URI 参数名完全匹配。

```伪代码
@resource("resource://config/{style_name}/{size_name}")
函数 get_config(style_name, size_name):
    # style_name 和 size_name 必须与 URI 中的参数名匹配
    返回 组合配置
```

### Q4: 可以返回什么类型的数据？

**A**: 可以返回字符串、字典、列表等可序列化的类型。FastMCP 会自动处理类型转换和序列化。

## 📖 总结

### 核心要点

1. **Resource Template = 动态 Resource**
   - URI 包含参数
   - 根据参数返回不同数据

2. **数据与接口分离**
   - 数据定义在模块级别
   - Resource Template 直接访问数据

3. **URI 设计要清晰**
   - 使用有意义的路径和参数名
   - 表达资源的层次结构

4. **错误处理要友好**
   - 提供有用的错误信息
   - 包含可用选项列表

5. **函数要简单专注**
   - 一个函数做一件事
   - 避免过度复杂

### 设计流程

```
1. 确定需求
   └─ 需要根据什么参数返回什么数据？

2. 设计 URI
   └─ URI 路径和参数如何设计？

3. 组织数据
   └─ 数据如何存储和组织？

4. 实现函数
   └─ 如何根据参数访问和返回数据？

5. 错误处理
   └─ 如何处理无效参数和异常情况？

6. 测试验证
   └─ 在 MCP Inspector 中测试各种场景
```

## 🎓 学习路径

1. **理解概念**：Resource Template 是什么，为什么需要它
2. **学习设计**：如何设计 URI 和函数
3. **实践练习**：实现简单的 Resource Template
4. **进阶应用**：实现复杂的组合查询
5. **最佳实践**：遵循设计原则和最佳实践

---

**记住**：Resource Template 的核心是**根据参数动态返回数据**，设计时要考虑数据组织、URI 设计和错误处理。

